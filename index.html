<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Juego tipo Doom </title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <script>
    // ─── CONFIGURACIÓN DEL CANVAS ─────────────────────────────
    const canvas = document.getElementById('gameCanvas');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const ctx = canvas.getContext('2d');
    const screenWidth = canvas.width;
    const screenHeight = canvas.height;

    // ─── FUNCIONES DE AYUDA ─────────────────────────────
    // Función para cargar texturas con CORS habilitado
    function loadTexture(src) {
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.src = src;
      return img;
    }

    // ─── CARGA DE TEXTURAS ─────────────────────────────
    const wallTexture    = loadTexture('wall.png');
    const floorTexture   = loadTexture('floor.png');
    const ceilingTexture = loadTexture('ceiling.png');
    const weaponTexture  = loadTexture('weapon.png');
    const enemyTexture   = loadTexture('enemy.png');

    // Variables para almacenar los datos (pixel data) de floor y ceiling
    let floorData = null, ceilingData = null;
    let texturesLoaded = 0;
    function onTextureLoaded() {
      texturesLoaded++;
      if (texturesLoaded === 5) {
        // Extrae los píxeles de la textura del suelo
        const floorCanvas = document.createElement('canvas');
        floorCanvas.width = floorTexture.width;
        floorCanvas.height = floorTexture.height;
        const floorCtx = floorCanvas.getContext('2d');
        floorCtx.drawImage(floorTexture, 0, 0);
        floorData = floorCtx.getImageData(0, 0, floorTexture.width, floorTexture.height).data;

        // Extrae los píxeles de la textura del techo
        const ceilingCanvas = document.createElement('canvas');
        ceilingCanvas.width = ceilingTexture.width;
        ceilingCanvas.height = ceilingTexture.height;
        const ceilingCtx = ceilingCanvas.getContext('2d');
        ceilingCtx.drawImage(ceilingTexture, 0, 0);
        ceilingData = ceilingCtx.getImageData(0, 0, ceilingTexture.width, ceilingTexture.height).data;

        // Inicia el bucle del juego
        requestAnimationFrame(gameLoop);
      }
    }
    wallTexture.onload    = onTextureLoaded;
    floorTexture.onload   = onTextureLoaded;
    ceilingTexture.onload = onTextureLoaded;
    weaponTexture.onload  = onTextureLoaded;
    enemyTexture.onload   = onTextureLoaded;

    // ─── DEFINICIÓN DEL MAPA (15x15) ─────────────────────────────
    // Mapa de 15x15: bordes de muros (valor 1) y “cava” una cruz (valor 0)
    const MAP_WIDTH = 15, MAP_HEIGHT = 15;
    const map = [];
    for (let y = 0; y < MAP_HEIGHT; y++) {
      const row = [];
      for (let x = 0; x < MAP_WIDTH; x++) {
        row.push(1);
      }
      map.push(row);
    }
    // Barra horizontal (filas 1 a 4, columnas 3 a 11)
    for (let y = 1; y <= 4; y++) {
      for (let x = 3; x <= 11; x++) {
        map[y][x] = 0;
      }
    }
    // Barra vertical (filas 4 a 13, columnas 6 a 8)
    for (let y = 4; y <= 13; y++) {
      for (let x = 6; x <= 8; x++) {
        map[y][x] = 0;
      }
    }

    // ─── VARIABLES DEL JUGADOR ─────────────────────────────
    let posX = 7.5, posY = 3.5;  // Posición inicial (dentro de la cruz)
    let angle = 0;             // Ángulo inicial (en radianes)
    const fov = Math.PI / 3;   // Campo de visión (60°)

    // Velocidades aumentadas para un movimiento más rápido
    const moveSpeed = 0.2;
    const rotSpeed  = 0.06;

    // ─── CONTROLES (WASD y FLECHAS) ─────────────────────────────
    const keys = {};
    window.addEventListener('keydown', e => { keys[e.key] = true; });
    window.addEventListener('keyup', e => { keys[e.key] = false; });

    // ─── SISTEMA DE DISPAROS ─────────────────────────────
    const bullets = [];
    const bulletSpeed = 0.5;
    let lastShotTime = 0;
    const shootCooldown = 300; // en milisegundos

    // Dispara al presionar la barra espaciadora
    window.addEventListener('keydown', e => {
      if (e.code === "Space") {
        const currentTime = Date.now();
        if (currentTime - lastShotTime > shootCooldown) {
          bullets.push({ x: posX, y: posY, angle: angle });
          lastShotTime = currentTime;
        }
      }
    });

    // ─── ENEMIGOS ─────────────────────────────
    // Cada enemigo tiene posición, estado (alive) y un posible cooldown para disparar (no implementado aquí)
    const enemies = [
      { x: 5.5,  y: 2.5,  alive: true },
      { x: 7.5,  y: 10.5, alive: true },
      { x: 10.5, y: 4.5,  alive: true }
    ];
    const enemySpeed = 0.02;

    // ─── ACTUALIZACIÓN DEL ESTADO ─────────────────────────────
    function update() {
      // Movimiento hacia adelante
      if (keys["ArrowUp"] || keys["w"]) {
        let newX = posX + Math.cos(angle) * moveSpeed;
        let newY = posY + Math.sin(angle) * moveSpeed;
        if (map[Math.floor(newY)][Math.floor(newX)] === 0) {
          posX = newX;
          posY = newY;
        }
      }
      // Movimiento hacia atrás
      if (keys["ArrowDown"] || keys["s"]) {
        let newX = posX - Math.cos(angle) * moveSpeed;
        let newY = posY - Math.sin(angle) * moveSpeed;
        if (map[Math.floor(newY)][Math.floor(newX)] === 0) {
          posX = newX;
          posY = newY;
        }
      }
      // Rotación
      if (keys["ArrowLeft"] || keys["a"]) {
        angle -= rotSpeed;
      }
      if (keys["ArrowRight"] || keys["d"]) {
        angle += rotSpeed;
      }

      // Actualización de los proyectiles
      for (let i = bullets.length - 1; i >= 0; i--) {
        let b = bullets[i];
        b.x += Math.cos(b.angle) * bulletSpeed;
        b.y += Math.sin(b.angle) * bulletSpeed;
        // Si el proyectil golpea un muro, se elimina
        if (!map[Math.floor(b.y)] || map[Math.floor(b.y)][Math.floor(b.x)] > 0) {
          bullets.splice(i, 1);
          continue;
        }
        // Colisión con enemigos
        for (let enemy of enemies) {
          if (enemy.alive) {
            let dx = enemy.x - b.x;
            let dy = enemy.y - b.y;
            if (Math.sqrt(dx*dx + dy*dy) < 0.3) { // umbral de colisión
              enemy.alive = false;
              bullets.splice(i, 1);
              break;
            }
          }
        }
      }

      // Movimiento simple de enemigos: se mueven lentamente hacia el jugador
      for (let enemy of enemies) {
        if (enemy.alive) {
          let dx = posX - enemy.x;
          let dy = posY - enemy.y;
          let dist = Math.sqrt(dx*dx + dy*dy);
          if (dist > 0.5) { // se aproxima hasta cierta distancia
            let newX = enemy.x + (dx/dist)*enemySpeed;
            let newY = enemy.y + (dy/dist)*enemySpeed;
            if (map[Math.floor(newY)][Math.floor(newX)] === 0) {
              enemy.x = newX;
              enemy.y = newY;
            }
          }
        }
      }
    }

    // ─── RENDERIZADO ─────────────────────────────
    function render() {
      // Limpia el canvas
      ctx.fillStyle = "#000";
      ctx.fillRect(0, 0, screenWidth, screenHeight);

      // Calcula parámetros de cámara
      const planeX = -Math.sin(angle) * Math.tan(fov / 2);
      const planeY = Math.cos(angle) * Math.tan(fov / 2);
      const dirX = Math.cos(angle);
      const dirY = Math.sin(angle);
      // ¡IMPORTANTE! Corrección en el cálculo de invDet para que la transformación de sprites funcione correctamente:
      const invDet = 1.0 / (planeX * dirY - dirX * planeY);
      const halfHeight = screenHeight / 2;
      const posZ = halfHeight; // Altura de la cámara respecto al suelo

      // ─── FLOOR & CEILING CASTING ─────────────────────────────
      // Se obtiene el ImageData del canvas para modificar píxel a píxel
      const imgData = ctx.getImageData(0, 0, screenWidth, screenHeight);
      const data = imgData.data;

      for (let y = 0; y < screenHeight; y++) {
        let p = y - halfHeight;
        if (p === 0) p = 1; // Evitar división por cero
        let rowDistance = posZ / Math.abs(p);

        // Paso en el mundo por cada píxel horizontal
        const floorStepX = rowDistance * ( (dirX + planeX) - (dirX - planeX) ) / screenWidth;
        const floorStepY = rowDistance * ( (dirY + planeY) - (dirY - planeY) ) / screenWidth;
        let worldX = posX + rowDistance * (dirX - planeX);
        let worldY = posY + rowDistance * (dirY - planeY);

        for (let x = 0; x < screenWidth; x++) {
          const cellX = Math.floor(worldX);
          const cellY = Math.floor(worldY);
          const pixelIndex = (y * screenWidth + x) * 4;
          if (y > halfHeight) {
            // Piso
            let tx = Math.floor((worldX - cellX) * floorTexture.width);
            let ty = Math.floor((worldY - cellY) * floorTexture.height);
            tx = ((tx % floorTexture.width) + floorTexture.width) % floorTexture.width;
            ty = ((ty % floorTexture.height) + floorTexture.height) % floorTexture.height;
            const texIndex = (ty * floorTexture.width + tx) * 4;
            data[pixelIndex    ] = floorData[texIndex    ];
            data[pixelIndex + 1] = floorData[texIndex + 1];
            data[pixelIndex + 2] = floorData[texIndex + 2];
            data[pixelIndex + 3] = 255;
          } else if (y < halfHeight) {
            // Techo
            let tx = Math.floor((worldX - cellX) * ceilingTexture.width);
            let ty = Math.floor((worldY - cellY) * ceilingTexture.height);
            tx = ((tx % ceilingTexture.width) + ceilingTexture.width) % ceilingTexture.width;
            ty = ((ty % ceilingTexture.height) + ceilingTexture.height) % ceilingTexture.height;
            const texIndex = (ty * ceilingTexture.width + tx) * 4;
            data[pixelIndex    ] = ceilingData[texIndex    ];
            data[pixelIndex + 1] = ceilingData[texIndex + 1];
            data[pixelIndex + 2] = ceilingData[texIndex + 2];
            data[pixelIndex + 3] = 255;
          }
          worldX += floorStepX;
          worldY += floorStepY;
        }
      }
      ctx.putImageData(imgData, 0, 0);

      // ─── RENDERIZADO DE LAS PAREDES (RAYCASTING) ─────────────────────────────
      for (let x = 0; x < screenWidth; x++) {
        const cameraX = 2 * x / screenWidth - 1;
        const rayDirX = dirX + planeX * cameraX;
        const rayDirY = dirY + planeY * cameraX;
        let mapX = Math.floor(posX);
        let mapY = Math.floor(posY);

        const deltaDistX = Math.abs(1 / rayDirX);
        const deltaDistY = Math.abs(1 / rayDirY);
        let stepX, stepY, sideDistX, sideDistY;
        if (rayDirX < 0) {
          stepX = -1;
          sideDistX = (posX - mapX) * deltaDistX;
        } else {
          stepX = 1;
          sideDistX = (mapX + 1 - posX) * deltaDistX;
        }
        if (rayDirY < 0) {
          stepY = -1;
          sideDistY = (posY - mapY) * deltaDistY;
        } else {
          stepY = 1;
          sideDistY = (mapY + 1 - posY) * deltaDistY;
        }

        let hit = false;
        let side;
        while (!hit) {
          if (sideDistX < sideDistY) {
            sideDistX += deltaDistX;
            mapX += stepX;
            side = 0;
          } else {
            sideDistY += deltaDistY;
            mapY += stepY;
            side = 1;
          }
          if (map[mapY][mapX] > 0) hit = true;
        }

        let perpWallDist;
        if (side === 0)
          perpWallDist = (mapX - posX + (1 - stepX) / 2) / rayDirX;
        else
          perpWallDist = (mapY - posY + (1 - stepY) / 2) / rayDirY;

        const lineHeight = Math.floor(screenHeight / perpWallDist);
        let drawStart = Math.floor(-lineHeight / 2 + screenHeight / 2);
        if (drawStart < 0) drawStart = 0;
        let drawEnd = Math.floor(lineHeight / 2 + screenHeight / 2);
        if (drawEnd >= screenHeight) drawEnd = screenHeight - 1;

        let wallX;
        if (side === 0)
          wallX = posY + perpWallDist * rayDirY;
        else
          wallX = posX + perpWallDist * rayDirX;
        wallX -= Math.floor(wallX);
        let texX = Math.floor(wallX * wallTexture.width);
        if (side === 0 && rayDirX > 0) texX = wallTexture.width - texX - 1;
        if (side === 1 && rayDirY < 0) texX = wallTexture.width - texX - 1;

        if (wallTexture.complete) {
          ctx.drawImage(
            wallTexture,
            texX, 0, 1, wallTexture.height,
            x, drawStart, 1, drawEnd - drawStart
          );
        } else {
          ctx.fillStyle = (side === 1) ? "#888" : "#aaa";
          ctx.fillRect(x, drawStart, 1, drawEnd - drawStart);
        }
      }

      // ─── RENDERIZADO DE ENEMIGOS (SPRITES) ─────────────────────────────
      for (let enemy of enemies) {
        if (enemy.alive) {
          const spriteX = enemy.x - posX;
          const spriteY = enemy.y - posY;
          const transformX = invDet * (dirY * spriteX - dirX * spriteY);
          const transformY = invDet * (-planeY * spriteX + planeX * spriteY);
          if (transformY > 0) {
            const spriteScreenX = Math.floor((screenWidth / 2) * (1 + transformX / transformY));
            const spriteHeight = Math.abs(Math.floor(screenHeight / transformY));
            const spriteWidth  = spriteHeight; // Suponemos sprite cuadrado
            const drawStartY = Math.floor(-spriteHeight / 2 + screenHeight / 2);
            const drawStartX = Math.floor(-spriteWidth / 2 + spriteScreenX);
            ctx.drawImage(enemyTexture, drawStartX, drawStartY, spriteWidth, spriteHeight);
          }
        }
      }

      // ─── RENDERIZADO DE PROYECTILES ─────────────────────────────
      for (let bullet of bullets) {
        const spriteX = bullet.x - posX;
        const spriteY = bullet.y - posY;
        const transformX = invDet * (dirY * spriteX - dirX * spriteY);
        const transformY = invDet * (-planeY * spriteX + planeX * spriteY);
        if (transformY > 0) {
          const spriteScreenX = Math.floor((screenWidth / 2) * (1 + transformX / transformY));
          const spriteSize = Math.abs(Math.floor(screenHeight / transformY)) / 8;
          const drawStartY = Math.floor(-spriteSize / 2 + screenHeight / 2);
          const drawStartX = Math.floor(-spriteSize / 2 + spriteScreenX);
          ctx.fillStyle = "yellow"; // La bala se dibuja en amarillo
          ctx.beginPath();
          ctx.arc(drawStartX + spriteSize/2, drawStartY + spriteSize/2, spriteSize/2, 0, 2 * Math.PI);
          ctx.fill();
        }
      }

      // ─── DIBUJA EL ARMA (HUD) ─────────────────────────────
      const weaponWidth = screenWidth * 0.5;
      const weaponHeight = weaponTexture.height * (weaponWidth / weaponTexture.width);
      const weaponX = (screenWidth - weaponWidth) / 2;
      const weaponY = screenHeight - weaponHeight;
      ctx.drawImage(weaponTexture, weaponX, weaponY, weaponWidth, weaponHeight);
    }

    // ─── BUCLE DEL JUEGO ─────────────────────────────
    function gameLoop() {
      update();
      render();
      requestAnimationFrame(gameLoop);
    }
  </script>
</body>
</html>
